<meta charset="UTF-8" />

<!-- Daniel teve uma ideia, primeiro, ele apresentou o seguinte trecho de código para seus amigos:

Aprendemos que a função prompt() retorna o que é digitado como texto e a função parseInt() converte um texto em número. Contudo, o que acontece se no lugar da idade for digitado um nome? O valor idade será NaN (not a number). Isso faz todo sentido, pois a função parseInt não é capaz de converter um texto como "Calopsita" para um número.

A ideia de Daniel é que enquanto o usuário não digitar um número, deve ser mostrado um aviso pedindo para que a idade seja digitada. Aprendemos que while é uma maneira de repetir instruções, em nosso caso, queremos repetir a leitura do teclado. Assim, Daniel escreveu o seguinte código:

Agora, quando o usuário digitar "Calopsita" idade será NaN. Portanto, a condição de repetição do while será a idade ser NaN. Perfeito! Mas estranhamente essa solução não funcionará!

Daniel verificou que se ele digitar qualquer coisa, seja um texto como "Calopsita" ou um número", o laço do while nunca é executado. Ele esta quase solucionando o problema, mas tem um detalhe, não podemos comparar nenhum valor, como NaN, usando ==. Se você abrir seu console agora e escrever NaN == NaN isso será falso! Esse resultado bizarro é uma característica da linguagem.

Para saber se um valor é NaN precisamos usar uma função específica, a isNaN. Essa função recebe um parâmetro e retorna true ou false caso o valor seja NaN ou não.

Sabendo que a função isNaN recebe um parâmetro e retorna true caso o parâmetro passado seja NaN, qual das opções abaixo altera corretamente o código de Daniel para usar a função isNaN? -->

<script>
  function pulaLinha() {
    document.write("<br>");
    document.write("<br>");
  }

  function mostra(frase) {
    document.write(frase);
    pulaLinha();
  }

  var idade = parseInt(prompt("Digite sua idade"));

  while (isNaN(idade)) {
    idade = parseInt(prompt("Digite sua idade"));
  }

  alert(idade);
</script>
